# MODULAR MATH
```bash
this section I read the instruction and use sympy
```
## Quadratic Residues
```python
from math import *

p = 29
ints = [14, 6, 11]
for intz in ints:
    for i in range(1,p):
        if i*i % p == intz:
            print(i)
            break
```

## Legendre Symbol
```python
from sympy.ntheory.residue_ntheory import legendre_symbol, _sqrt_mod_tonelli_shanks as mod_sqrt
p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139
ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]
print([mod_sqrt(a, p) for a in ints if legendre_symbol(a, p)==1][0])
```

## Modular Square Root
```python
from sympy.ntheory.residue_ntheory import sqrt_mod
a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

print(sqrt_mod(a, p))
```

## Chinese Remainder Theorem
```python
from sympy.ntheory.modular import crt

print(crt([5, 11, 17], [2, 3, 5]))
```

# LATTICES
## Vectors
```bash
I just compute it, got 702
```

## Size and Basis
```bash
Same as above challenge, got 9
```

## Gram Schmidt
I use knowledge in LIA class to build and use it
```python
def dot_product(a, b):
    dp = 0
    for i in range(4):
        dp = dp + a[i]*b[i]
    return dp
    
def add(a, b):
    return (a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3])

def subtract(a, b):
    return (a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3])

def mul(k, a):
    return (a[0] * k, a[1] * k, a[2] * k, a[3] * k)

def round_(u, k):
    return (round(u[0], k), round(u[1], k), round(u[2], k), round(u[3], k))

v = [(0,0,0,0), (4,1,3,-1), (2,1,-3,4), (1,0,-2,7), (6, 2, 9, -5)]
u = [(0,0,0,0), (4,1,3,-1)]

for i in range(2, 5):
    s = v[i]
    for j in range(1, i):
        k = dot_product(u[j], s) / dot_product(u[j], u[j])
        s = subtract(s, mul(k, u[j]))
    u.append(s)

for i in range(1, 5):
    print(round_(u[i], 5))
```

## What's a Lattice?
```bash
I compute its determinant, got det = 225
```

## Gaussian Reduction
I use knowledge in LIA class to built and use it. <br/>
Or you may write code in sage and just use LLL func.
```python
from math import sqrt

def dot_product(a, b):
    dp = 0
    for i in range(2):
        dp = dp + a[i]*b[i]
    return dp

def size(v):
    return sqrt(v[0]**2 + v[1]**2)

def subtract(a, b):
    return (a[0] - b[0], a[1] - b[1])

def mul(k, a):
    return (a[0] * k, a[1] * k)

def Guassian(v1, v2):
    if size(v2) <= size(v1):
        c = v2
        v2 = v1
        v1 = c
    m = round(dot_product(v1, v2) / dot_product(v1, v1))
    return (v1, v2) if m == 0 else Guassian(v1, subtract(v2, mul(m, v1)))

def main():
    v = (846835985, 9834798552)
    u = (87502093, 123094980)
    guass = Guassian(v,u)
    print(dot_product(guass[0], guass[1]))

if __name__ == "__main__":
    main()
```

## Find the Lattice
I use the code from prev challenge to solve this one
```python
from math import sqrt
from Crypto.Util.number import getPrime, inverse, bytes_to_long

def decrypt(q, h, f, g, e):
    a = (f * e) % q
    m = ((f * e) % q * inverse(f, g)) % g
    return m

def dot_product(a, b):
    dp = 0
    for i in range(2):
        dp = dp + a[i]*b[i]
    return dp

def size(v):
    return sqrt(v[0]**2 + v[1]**2)

def subtract(a, b):
    return (a[0] - b[0], a[1] - b[1])

def mul(k, a):
    return (a[0] * k, a[1] * k)

def Guassian(v1, v2):
    # print(v1, v2)
    if size(v2) <= size(v1):
        c = v2
        v2 = v1
        v1 = c
    # print(v1, v2)
    m = round(dot_product(v1, v2) / dot_product(v1, v1))
    if m == 0:
        return (v1, v2)
    v2 = subtract(v2, mul(m, v1))
    return Guassian(v1, v2)

q = 7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257
h = 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800
e = 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523
v = (1, h)
u = (0, q)
f, g = Guassian(v, u)[1]
m = decrypt(q,h,f,g,e)
print(bytes.fromhex(hex(m)[2:]).decode())
```

## Backpack Cryptography
I use [Knapsack](http://www.cs.sjsu.edu/faculty/stamp/papers/topics/topic16/Knapsack.pdf) to find the satisfy row.<br/>
See [the code](https://github.com/whynotkimhari/cryptography/blob/main/cryptohack%20problems/mathematics/lattices/backpackCryptography.py) for more details.<br/>
Intruction that I read at [CSDN](https://blog.csdn.net/wt20180112/article/details/124028964).<br/>
After got the row, I implement this to find the flag.<br/>
```python
from Crypto.Util.number import long_to_bytes
sastify_row = [-1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 0]
bin = ''
for _ in sastify_row:
    if _ == 1:
        bin = '0' + bin
    else:
        bin = '1' + bin

print(long_to_bytes(int(bin, 2)))
```

# BRAINTEASERS PART 1
## Successive Powers
```bash
x is int -> just 836/4 is int -> got x = 209
use x to find back p
```
```python
from math import *
print("crypto{%d, %d}" % (gcd(114 * 209 - 851, 642 * 209 - 4), 836//4))
```

## Adrien's Signs
I use Legendre symbol to solve this
```python
from sympy.ntheory import legendre_symbol
p = 1007621497415251
c = [67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]
print(bytes.fromhex(hex(int(''.join(['1' if legendre_symbol(i,p)==1 else '0' for i in c]), 2))[2:]).decode())
```

## Modular Binomials
Write it down to have a system to solve
```python
from math import gcd

n = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073
e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051
c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519

q1 = pow(c1, e2, n)
q2 = pow(c2, e1, n)
d = pow(5, e1 * e2, n) * q1 - pow(2, e1 * e2, n) * q2
q = gcd(d, n)
p = n // q
print("crypto{%d,%d}" % (p,q))
```

## Broken RSA
I have read the instruction to solve this somewhere, but now I can't find it back.
```python
from sympy.ntheory.residue_ntheory import sqrt_mod

n = 27772857409875257529415990911214211975844307184430241451899407838750503024323367895540981606586709985980003435082116995888017731426634845808624796292507989171497629109450825818587383112280639037484593490692935998202437639626747133650990603333094513531505209954273004473567193235535061942991750932725808679249964667090723480397916715320876867803719301313440005075056481203859010490836599717523664197112053206745235908610484907715210436413015546671034478367679465233737115549451849810421017181842615880836253875862101545582922437858358265964489786463923280312860843031914516061327752183283528015684588796400861331354873
ct = 11303174761894431146735697569489134747234975144162172162401674567273034831391936916397234068346115459134602443963604063679379285919302225719050193590179240191429612072131629779948379821039610415099784351073443218911356328815458050694493726951231241096695626477586428880220528001269746547018741237131741255022371957489462380305100634600499204435763201371188769446054925748151987175656677342779043435047048130599123081581036362712208692748034620245590448762406543804069935873123161582756799517226666835316588896306926659321054276507714414876684738121421124177324568084533020088172040422767194971217814466953837590498718

for a in sqrt_mod(ct, n, all_roots=True):
    for b in sqrt_mod(a, n, all_roots=True):
        for c in sqrt_mod(b, n, all_roots=True):
            for d in sqrt_mod(c, n, all_roots=True):
                try:
                    print(bytes.fromhex(hex(d)[2:]).decode())
                except:
                    continue
```                    

# BRAINTEASERS PART 2
## Roll your Own
Same as Broken RSA, that page seem to be deleted.
```python
from pwn import remote
from json import loads, dumps

io = remote('socket.cryptohack.org', 13403)
io.readuntil(b'Prime generated: "')
q = int(io.readline()[:-2], 16)
io.sendline(dumps({"g":hex(q+1), "n":hex(q**2)}).encode())
io.readuntil(b'Generated my public key: "')
pub = int(io.readline()[:-2], 16)
io.sendline(dumps({"x":hex((pub-1)//q)}).encode())
io.readuntil(b'What is my private key: ')
print(loads(io.readline().decode())['flag'])
```

## Unencryptable
This challenge may in RSA task. I just use knowledge in that task to solve.
```python
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes
N = 89820998365358013473897522178239129504456795742012047145284663770709932773990122507570315308220128739656230032209252739482850153821841585443253284474483254217510876146854423759901130591536438014306597399390867386257374956301247066160070998068007088716177575177441106230294270738703222381930945708365089958721
e = 65537
c = 57724595041655272359404081330243782612007490775620455952856783793829194855405918774122658126113651645266109772326418684386267436657365090201416997710368856779651733795768645396189374842935059696319569370108775354486777352615188429246558509723548640515101350311582378064825617510607977995871758901718229542779

### GOTO http://factordb.com/index.php?query=89820998365358013473897522178239129504456795742012047145284663770709932773990122507570315308220128739656230032209252739482850153821841585443253284474483254217510876146854423759901130591536438014306597399390867386257374956301247066160070998068007088716177575177441106230294270738703222381930945708365089958721
p = 8239835397208516111720362847949425401045672365829937602117480449316694558226622200110057535873802132963548914201468383545676262090246827792522994758916609
q = 10900824353334471830007307529937357926160386461967884446160315218630687793341471079170750548554707926611542019859296605188535413447791710067186432371970369
phi = (p-1)*(q-1)
d = inverse(e,phi)
pt = pow(c, d, N)
print(long_to_bytes(pt))
```

## Cofactor Cofantasy
Same as Broken RSA and Roll your Own.<br/>
This challenge may take a little bit of time.
```python
from pwn import remote
from json import loads, dumps
from math import gcd

def determine(i):
    for _ in range(2):
        io.sendline(dumps({'option': 'get_bit', 'i': str(i)}).encode())
        res = int(loads(io.recvline())['bit'], 16)
        if pow(g, phi//(2**e), b) != pow(res, phi//(2**e), b):
            return '0'
    return '1'

N = 56135841374488684373258694423292882709478511628224823806418810596720294684253418942704418179091997825551647866062286502441190115027708222460662070779175994701788428003909010382045613207284532791741873673703066633119446610400693458529100429608337219231960657953091738271259191554117313396642763210860060639141073846574854063639566514714132858435468712515314075072939175199679898398182825994936320483610198366472677612791756619011108922142762239138617449089169337289850195216113264566855267751924532728815955224322883877527042705441652709430700299472818705784229370198468215837020914928178388248878021890768324401897370624585349884198333555859109919450686780542004499282760223378846810870449633398616669951505955844529109916358388422428604135236531474213891506793466625402941248015834590154103947822771207939622459156386080305634677080506350249632630514863938445888806223951124355094468682539815309458151531117637927820629042605402188751144912274644498695897277
phi = 56135841374488684373258694423292882709478511628224823806413974550086974518248002462797814062141189227167574137989180030483816863197632033192968896065500768938801786598807509315219962138010136188406833851300860971268861927441791178122071599752664078796430411769850033154303492519678490546174370674967628006608839214466433919286766123091889446305984360469651656535210598491300297553925477655348454404698555949086705347702081589881912691966015661120478477658546912972227759596328813124229023736041312940514530600515818452405627696302497023443025538858283667214796256764291946208723335591637425256171690058543567732003198060253836008672492455078544449442472712365127628629283773126365094146350156810594082935996208856669620333251443999075757034938614748482073575647862178964169142739719302502938881912008485968506720505975584527371889195388169228947911184166286132699532715673539451471005969465570624431658644322366653686517908000327238974943675848531974674382848
g = 986762276114520220801525811758560961667498483061127810099097
e = 16
b = gcd(N, pow(g, phi//(2**e), N) - 1)

io = remote('socket.cryptohack.org', 13398)
io.recvline()

flag_bin = ''
flag = ''
for i in range(43*8):
    flag_bin += determine(i)
    if (i+1) % 8 == 0:
        flag = bytes.fromhex(hex(int(flag_bin[::-1], 2))[2:])[::-1]
    print(flag_bin)
    print(flag)
```    

## Real Eisenstein
Note that this code in sage.<br/>
Instruction I read in this [CSDN](https://blog.csdn.net/weixin_52446095/article/details/116719649)
```sage
from decimal import *
import math

getcontext().prec = int(100)
PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]
keys = [Decimal(int(_)).sqrt() for _ in PRIMES]
arr = [int(v * int(16) ** int(64)) for v in keys]
ct = 1350995397927355657956786955603012410260017344805998076702828160316695004588429433

def enc(res):
    h = Decimal(int(0))
    for i in range(len(keys)):
        h += res[i] * keys[i]
    ct = int(h * int(16) ** int(64))
    return ct

def sol(N):
    ln = len(arr)
    A = Matrix(ZZ, ln + 1, ln + 1)
    for i in range(ln):
        A[i,i] = 1
        A[i, ln] = arr[i] // N
        A[ln, i] = 64
    A[ln,ln] = ct // N
    res = A.LLL()
    
    for i in range(ln + 1):
        flag = True
        for j in range(ln):
            if -64 <= res[i][j] < 64:
                continue
            flag = False
            break
        if flag:
            vec = [int(v + 64) for v in res[i][:-1]]
            ret = enc(vec)
            if ret == ct:
                print(N, bytes(vec))
            else:
                print("No", ret, bytes(vec))
            return bytes(vec)
    
for i in range(2, 100000):
    try:
        if b'crypto' in sol(i):
            break
    except TypeError:
        continue
```

# PRIMES
## Prime and Prejudice
This challenge I use [this](https://github.com/loluwot/StrongPseudoPrimeGeneratorMkII/blob/main/sol.py) to find prime and base.
```python
from Crypto.Util.number import getPrime
from sympy import *
import pwn
import json
import math
prime = 254615674198066111348559108472798769684001878358857095506953165173728617744160791637392778869123081942910652286182625202904553164094373753256627211722903336405144072652128620402472907
base = 1030617353352977080364307518770663528633732979071959749923
r = pwn.remote('socket.cryptohack.org', 13385)

def json_recv():
    line = r.recvline()
    return json.loads(line.decode())

def json_send(hsh):
    request = json.dumps(hsh).encode()
    r.sendline(request)

r.recvline()
json_send({'prime': prime, 'base' : base})
line = json_recv()
print(line)
```
